import {constants, open} from 'node:fs/promises'
import {dirname, join} from 'node:path'

import {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'
import {readConfig} from '@sanity/codegen'
import readPkgUp from 'read-pkg-up'
import {Worker} from 'worker_threads'

import {
  type CodegenGenerateWorkerData,
  type CodegenGenerateWorkerMessage,
} from '../../threads/codegenGenerateTypes'
import {getTimer} from '../../util/timing'

export interface CodegenGenerateTypesCommandFlags {
  configPath?: string
}

export default async function codegenGenerateAction(
  args: CliCommandArguments<CodegenGenerateTypesCommandFlags>,
  context: CliCommandContext,
): Promise<void> {
  const timers = getTimer()
  const flags = args.extOptions
  const {output, workDir} = context

  timers.start('codegen.generateTypesAction')

  const codegenConfig = await readConfig(flags.configPath || 'sanity-codegen.json')

  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path
  if (!rootPkgPath) {
    throw new Error('Could not find root directory for `sanity` package')
  }

  const workerPath = join(
    dirname(rootPkgPath),
    'lib',
    '_internal',
    'cli',
    'threads',
    'codegenGenerateTypes.js',
  )

  const spinner = output.spinner({prefixText: 'âœ¨', text: 'Generating types'}).start()

  const worker = new Worker(workerPath, {
    workerData: {
      workDir,
      config: codegenConfig,
    } satisfies CodegenGenerateWorkerData,
    // eslint-disable-next-line no-process-env
    env: process.env,
  })

  const typeFile = await open(
    join(process.cwd(), codegenConfig.generates),
    // eslint-disable-next-line no-bitwise
    constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY,
  )

  typeFile.write('// This file is generated by `sanity codegen generate`\n')

  const stats = {
    files: 0,
    errors: 0,
    queries: 0,
  }

  await new Promise<void>((resolve, reject) => {
    worker.addListener('message', (msg: CodegenGenerateWorkerMessage) => {
      if ('error' in msg) {
        if (msg.fatal) {
          reject(msg.error)
        } else {
          spinner.fail(msg.error.message)
          stats.errors++
        }
        return
      }
      if ('complete' in msg) {
        resolve()
        return
      }

      let fileTypeString = `// ${msg.filename}\n`

      if (typeof msg.types === 'string') {
        fileTypeString += `${msg.types}\n\n`
        typeFile.write(fileTypeString)
        return
      }

      stats.files++
      for (const {queryName, query, type} of msg.types) {
        fileTypeString += `// ${queryName}\n`
        fileTypeString += `// ${query.replace(/(\r\n|\n|\r)/gm, '')}\n`
        fileTypeString += `${type}\n`
        stats.queries++
      }
      typeFile.write(`${fileTypeString}\n`)
    })
    worker.addListener('error', reject)
  })

  typeFile.close()

  timers.end('codegen.generateTypesAction')
  spinner.succeed(
    `Generated codegen types for ${stats.queries} queries in ${stats.files} files, failed to parse ${stats.errors} files`,
  )
}
